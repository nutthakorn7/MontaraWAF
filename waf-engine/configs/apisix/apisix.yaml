# APISIX Routes Configuration - WAF Blocking Mode
# apisix.yaml for standalone mode with security plugins

routes:
  # Main WAF-protected route
  - id: 1
    uri: /*
    name: waf-protected-route
    plugins:
      # DDoS Protection - Rate Limiting
      limit-req:
        rate: 100
        burst: 200
        key: remote_addr
        rejected_code: 429
        rejected_msg: '{"error": "DDoS Protection: Rate limit exceeded", "code": 429, "type": "rate_limit"}'
      
      # DDoS Protection - Concurrent Connection Limit
      limit-conn:
        conn: 50
        burst: 100
        default_conn_delay: 0.1
        key: remote_addr
        rejected_code: 503
        rejected_msg: '{"error": "DDoS Protection: Too many connections", "code": 503, "type": "conn_limit"}'
      
      # IP Restriction - Block specific IPs
      ip-restriction:
        blacklist:
          - "0.0.0.0/32"  # Placeholder - add real IPs via API
        message: '{"error": "IP blocked by WAF", "code": 403}'
      
      # User-Agent Restriction - Block bad bots
      ua-restriction:
        denylist:
          - "curl*"
          - "python-requests*"
          - "Go-http-client*"
          - "Wget*"
          - "sqlmap*"
          - "Nikto*"
          - "dirbuster*"
          - "masscan*"
          - "nmap*"
          - "zgrab*"
          - "MJ12bot*"
          - "AhrefsBot*"
          - "SemrushBot*"
          - "DotBot*"
        bypass_missing: false
        message: '{"error": "Bot blocked by WAF", "code": 403}'
      
      # Request validation
      request-validation:
        header_schema:
          type: object
        rejected_code: 400
      
      # Prometheus metrics
      prometheus:
        prefer_name: true
      
      # Request ID for tracing
      request-id:
        header_name: X-Request-ID
        include_in_response: true
      
      # Custom WAF rules via serverless function
      serverless-pre-function:
        phase: rewrite
        functions:
          - |
            return function(conf, ctx)
              local cjson = require("cjson.safe")
              
              local uri = ngx.var.uri or ""
              local args = ngx.var.args or ""
              local client_ip = ngx.var.remote_addr
              local full_request = uri .. "?" .. args
              
              -- CrowdSec LAPI Check (optional, continue if unreachable)
              local crowdsec_url = "http://crowdsec:8080"
              local bouncer_key = "7lKoHLDqBWtmwSEgJMNVsx7Q/A8XrlIo4p7UhnIv18A"
              
              local ok, http = pcall(require, "resty.http")
              if ok then
                local httpc = http.new()
                httpc:set_timeout(500)  -- 500ms timeout
                
                local res, err = httpc:request_uri(crowdsec_url .. "/v1/decisions?ip=" .. client_ip, {
                  method = "GET",
                  headers = {
                    ["X-Api-Key"] = bouncer_key,
                  }
                })
                
                if res and res.status == 200 and res.body then
                  local decisions = cjson.decode(res.body)
                  if decisions and type(decisions) == "table" and #decisions > 0 then
                    local decision = decisions[1]
                    if decision.type == "ban" then
                      ngx.status = 403
                      ngx.header["Content-Type"] = "application/json"
                      ngx.say('{"error": "IP banned by CrowdSec", "code": 403, "reason": "' .. (decision.scenario or "unknown") .. '"}')
                      return ngx.exit(403)
                    elseif decision.type == "captcha" then
                      ngx.status = 403
                      ngx.header["Content-Type"] = "application/json"
                      ngx.say('{"error": "Captcha required", "code": 403, "challenge": "captcha"}')
                      return ngx.exit(403)
                    end
                  end
                end
              end
              
              -- URL decode function
              local function url_decode(str)
                str = string.gsub(str, "%%(%x%x)", function(h)
                  return string.char(tonumber(h, 16))
                end)
                str = string.gsub(str, "+", " ")
                return str
              end
              
              -- Decode URL-encoded characters
              local decoded_request = url_decode(full_request)
              local check_string = string.lower(decoded_request)
              
              -- SQL Injection patterns (more comprehensive)
              local sql_patterns = {
                "union[%s%%20]+select",
                "select[%s%%20]+.+[%s%%20]+from",
                "insert[%s%%20]+into",
                "delete[%s%%20]+from",
                "drop[%s%%20]+table",
                "or[%s%%20]+1[%s%%20]*=[%s%%20]*1",
                "and[%s%%20]+1[%s%%20]*=[%s%%20]*1",
                "'[%s%%20]*or[%s%%20]*'",
                "1'[%s%%20]*or[%s%%20]*'1'[%s%%20]*=[%s%%20]*'1",
                "exec[%s%%20]*%(",
                "xp_cmdshell",
                "concat%(.*select",
                "information_schema",
                "sleep%([%d]+%)",
                "benchmark%(",
                "load_file%(",
                "into[%s%%20]+outfile",
                "into[%s%%20]+dumpfile",
                "'[%s]*%-%-",
                "';[%s]*%-%-",
                "1=1",
                "1' or '1",
                "' or ''='",
                "admin'%-%-"
              }
              
              for _, pattern in ipairs(sql_patterns) do
                if string.match(check_string, pattern) then
                  ngx.status = 403
                  ngx.header["Content-Type"] = "application/json"
                  ngx.say('{"error": "SQL Injection blocked by WAF", "code": 403, "rule": "942100"}')
                  return ngx.exit(403)
                end
              end
              
              -- XSS patterns
              local xss_patterns = {
                "<script",
                "javascript:",
                "onerror%s*=",
                "onload%s*=",
                "onclick%s*=",
                "onmouseover%s*=",
                "<iframe",
                "<img%s+.*onerror"
              }
              
              for _, pattern in ipairs(xss_patterns) do
                if string.match(string.lower(full_request), pattern) then
                  ngx.status = 403
                  ngx.header["Content-Type"] = "application/json"
                  ngx.say('{"error": "XSS blocked by WAF", "code": 403, "rule": "941100"}')
                  return ngx.exit(403)
                end
              end
              
              -- Path Traversal patterns
              local traversal_patterns = {
                "%.%.%/",
                "%.%.\\",
                "/etc/passwd",
                "/etc/shadow",
                "c:\\windows"
              }
              
              for _, pattern in ipairs(traversal_patterns) do
                if string.match(string.lower(full_request), pattern) then
                  ngx.status = 403
                  ngx.header["Content-Type"] = "application/json"
                  ngx.say('{"error": "Path Traversal blocked by WAF", "code": 403, "rule": "930100"}')
                  return ngx.exit(403)
                end
              end
              
              -- Remote Code Execution (RCE) patterns - OWASP 932100
              local rce_patterns = {
                "system%s*%(",
                "exec%s*%(",
                "shell_exec%s*%(",
                "passthru%s*%(",
                "popen%s*%(",
                "proc_open%s*%(",
                "pcntl_exec%s*%(",
                "eval%s*%(",
                "assert%s*%(",
                "preg_replace.*%/e",
                "create_function%s*%(",
                "`.*`",
                "%$%(.*%)",
                "os%.system",
                "subprocess%.",
                "runtime%.exec",
                "processbuilder",
                "%|%s*bash",
                "%|%s*sh",
                "%|%s*cmd",
                ";&",
                "%|%|",
                "nc%s+%-e",
                "bash%s+%-i",
                "/bin/bash",
                "/bin/sh",
                "powershell",
                "cmd%.exe"
              }
              
              for _, pattern in ipairs(rce_patterns) do
                if string.match(check_string, pattern) then
                  ngx.status = 403
                  ngx.header["Content-Type"] = "application/json"
                  ngx.say('{"error": "Remote Code Execution blocked by WAF", "code": 403, "rule": "932100"}')
                  return ngx.exit(403)
                end
              end
              
              -- Local File Inclusion (LFI) patterns - OWASP 930100
              local lfi_patterns = {
                "file://",
                "php://input",
                "php://filter",
                "php://data",
                "expect://",
                "zip://",
                "phar://",
                "data:text/html",
                "data:application",
                "/proc/self",
                "/proc/version",
                "/var/log/",
                "/var/www/",
                "boot%.ini",
                "win%.ini",
                "web%.config",
                "%.htaccess",
                "%.htpasswd",
                "httpd%.conf",
                "nginx%.conf",
                "my%.cnf",
                "php%.ini"
              }
              
              for _, pattern in ipairs(lfi_patterns) do
                if string.match(check_string, pattern) then
                  ngx.status = 403
                  ngx.header["Content-Type"] = "application/json"
                  ngx.say('{"error": "Local File Inclusion blocked by WAF", "code": 403, "rule": "930110"}')
                  return ngx.exit(403)
                end
              end
              
              -- Remote File Inclusion (RFI) patterns - OWASP 931100  
              local rfi_patterns = {
                "http://[^%s]+%.php",
                "http://[^%s]+%.txt",
                "https://[^%s]+%.php",
                "ftp://",
                "dict://",
                "gopher://",
                "ldap://",
                "sftp://",
                "tftp://"
              }
              
              for _, pattern in ipairs(rfi_patterns) do
                if string.match(check_string, pattern) then
                  ngx.status = 403
                  ngx.header["Content-Type"] = "application/json"
                  ngx.say('{"error": "Remote File Inclusion blocked by WAF", "code": 403, "rule": "931100"}')
                  return ngx.exit(403)
                end
              end
              
              -- Protocol Attack patterns - OWASP 921000
              local protocol_patterns = {
                "%%00",
                "%%0d%%0a",
                "%%0a",
                "%%0d",
                "\\x00",
                "\\r\\n",
                "content%-type:.*multipart",
                "transfer%-encoding:.*chunked"
              }
              
              for _, pattern in ipairs(protocol_patterns) do
                if string.match(check_string, pattern) then
                  ngx.status = 403
                  ngx.header["Content-Type"] = "application/json"
                  ngx.say('{"error": "Protocol Attack blocked by WAF", "code": 403, "rule": "921000"}')
                  return ngx.exit(403)
                end
              end
            end
    
    upstream:
      type: roundrobin
      nodes:
        "host.docker.internal:3000": 1
      timeout:
        connect: 5
        send: 10
        read: 10

# Health check route (bypass WAF)
  - id: 2
    uri: /health
    name: health-check
    plugins:
      prometheus:
        prefer_name: true
    upstream:
      type: roundrobin
      nodes:
        "host.docker.internal:3000": 1

#END
